"""Malware Analysis Tools"""

import time
import subprocess
import os
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.prompt import Prompt
from rich import box
from .base_tool import BaseTool


class MalwareAnalysisTools(BaseTool):
    def __init__(self, console: Console):
        super().__init__(console)
        
    def static_analysis(self):
        """Perform static malware analysis"""
        self.display_header("Static Malware Analysis")
        
        file_path = Prompt.ask("[cyan]Enter file path for static analysis[/cyan]")
        
        if not os.path.isfile(file_path):
            self.display_result("Invalid file path", "error")
            return
            
        self.console.print(f"[cyan]Performing static analysis on [green]{file_path}[/green][/cyan]")
        
        # Check for YARA
        try:
            result = subprocess.run(['yara', '--help'], capture_output=True, text=True, timeout=10)
            has_yara = True
        except (subprocess.CalledProcessError, FileNotFoundError):
            has_yara = False
        
        if has_yara:
            self.console.print("[green]YARA is available for signature-based detection[/green]")
            try:
                # Run basic YARA scan with built-in rules if available
                result = subprocess.run(['yara', file_path], capture_output=True, text=True, timeout=30)
                if result.returncode == 0:
                    output = result.stdout
                    if output.strip():
                        self.console.print("[bold green]YARA detections:[/bold green]")
                        for line in output.split('\n'):
                            if line.strip():
                                self.console.print(f"  [red]{line}[/red]")
                    else:
                        self.console.print("[green]No YARA rule matches found.[/green]")
                else:
                    self.display_result(f"YARA scan failed with code {result.returncode}", "error")
            except subprocess.TimeoutExpired:
                self.display_result("Static analysis timed out", "error")
            except Exception as e:
                self.display_result(f"Error during YARA scan: {e}", "error")
        else:
            self.console.print("[yellow]YARA not found. Install YARA for signature-based malware detection.[/yellow]")
            self.console.print("[dim]In a real implementation, this would analyze file signatures, packers, and potential malicious patterns[/dim]")
        
        # File type identification
        try:
            result = subprocess.run(['file', file_path], capture_output=True, text=True, timeout=10)
            if result.returncode == 0:
                self.console.print(f"[bold cyan]File type:[/bold cyan] {result.stdout.strip()}")
            else:
                self.display_result(f"File type identification failed with code {result.returncode}", "error")
        except (subprocess.CalledProcessError, FileNotFoundError):
            # Fallback to Python-based file type detection
            import magic
            try:
                file_type = magic.from_file(file_path)
                self.console.print(f"[bold cyan]File type:[/bold cyan] {file_type}")
            except:
                self.console.print("[yellow]File type identification tools not available.[/yellow]")
        except subprocess.TimeoutExpired:
            self.display_result("File type identification timed out", "error")
        except Exception as e:
            self.display_result(f"Error during file type identification: {e}", "error")
        
        # String extraction
        self.console.print("[cyan]Extracting strings...[/cyan]")
        try:
            result = subprocess.run(['strings', file_path], capture_output=True, text=True, timeout=30)
            if result.returncode == 0:
                lines = result.stdout.split('\n')
                # Filter and show interesting strings
                interesting_strings = []
                for line in lines:
                    if len(line) > 4 and not line.startswith(' ') and not line.endswith(' '):
                        interesting_strings.append(line)
                
                if interesting_strings:
                    self.console.print(f"[bold green]Found {len(interesting_strings)} potentially interesting strings:[/bold green]")
                    for s in interesting_strings[:15]:  # Show first 15 strings
                        self.console.print(f"  [cyan]{s}[/cyan]")
                else:
                    self.console.print("[yellow]No interesting strings found.[/yellow]")
            else:
                self.display_result(f"String extraction failed with code {result.returncode}", "error")
        except (subprocess.CalledProcessError, FileNotFoundError):
            self.console.print("[yellow]strings command not found. Install binutils for string extraction.[/yellow]")
        except subprocess.TimeoutExpired:
            self.display_result("String extraction timed out", "error")
        except Exception as e:
            self.display_result(f"Error during string extraction: {e}", "error")
    
    def dynamic_analysis(self):
        """Perform dynamic malware analysis"""
        self.display_header("Dynamic Malware Analysis")
        
        self.console.print("[cyan]Setting up sandbox environment for dynamic analysis...[/cyan]")
        self.console.print("[yellow]Note: This requires a sandbox environment like Cuckoo, ANY.RUN, or similar[/yellow]")
        self.console.print("[dim]In a real implementation, this would execute the malware in an isolated environment to observe behavior[/dim]")
        
        # Check for sandbox tools
        sandbox_tools = ['cuckoo', 'vmrun', 'docker']
        available_tools = []
        
        for tool in sandbox_tools:
            try:
                result = subprocess.run([tool, '--help'], capture_output=True, text=True, timeout=10)
                available_tools.append(tool)
            except (subprocess.CalledProcessError, FileNotFoundError):
                pass
        
        if available_tools:
            self.console.print(f"[bold green]Available sandbox tools: {', '.join(available_tools)}[/bold green]")
            file_path = Prompt.ask("[cyan]Enter file path for dynamic analysis[/cyan]")
            
            if not os.path.isfile(file_path):
                self.display_result("Invalid file path", "error")
                return
                
            self.console.print(f"[cyan]Submitting [green]{file_path}[/green] to sandbox environment...[/cyan]")
            self.console.print("[green]Dynamic analysis initiated (demo).[/green]")
            self.console.print("[dim]In a real implementation, this would monitor process creation, network activity, file system changes, and registry modifications[/dim]")
        else:
            self.console.print("[red]No sandbox tools found. Install Cuckoo, Docker, or VMware for dynamic analysis.[/red]")
            self.console.print("[yellow]Feature not available: No dynamic analysis tools found. (Demo only)[/yellow]")
    
    def network_monitoring(self):
        """Monitor network traffic for malware communications"""
        self.display_header("Network Traffic Monitoring")
        
        self.console.print("[cyan]Monitoring network traffic for potential malware communications...[/cyan]")
        self.console.print("[yellow]Note: This requires network monitoring tools like Wireshark, tcpdump, or Zeek[/yellow]")
        self.console.print("[dim]In a real implementation, this would capture and analyze network traffic for C2 communications[/dim]")
        
        # Check for network monitoring tools
        net_tools = ['wireshark', 'tcpdump', 'tshark', 'zeek']
        available_tools = []
        
        for tool in net_tools:
            try:
                result = subprocess.run([tool, '--help'], capture_output=True, text=True, timeout=10)
                available_tools.append(tool)
            except (subprocess.CalledProcessError, FileNotFoundError):
                pass
        
        if available_tools:
            self.console.print(f"[bold green]Available network monitoring tools: {', '.join(available_tools)}[/bold green]")
            interface = Prompt.ask("[cyan]Enter network interface to monitor (e.g., eth0, wlan0)[/cyan]", default="eth0")
            
            self.console.print(f"[cyan]Starting network monitoring on interface [green]{interface}[/green]...[/cyan]")
            self.console.print("[green]Network monitoring initiated (demo).[/green]")
            self.console.print("[dim]In a real implementation, this would detect suspicious connections, DNS queries, and data exfiltration attempts[/dim]")
        else:
            self.console.print("[red]No network monitoring tools found. Install Wireshark, tcpdump, or Zeek for network analysis.[/red]")
            self.console.print("[yellow]Feature not available: No network monitoring tools found. (Demo only)[/yellow]")
    
    def memory_analysis(self):
        """Analyze memory dumps for malware artifacts"""
        self.display_header("Memory Dump Analysis")
        
        self.console.print("[cyan]Analyzing memory dumps for malware artifacts...[/cyan]")
        self.console.print("[yellow]Note: This requires memory forensic tools like Volatility[/yellow]")
        self.console.print("[dim]In a real implementation, this would search memory dumps for injected code, mutexes, and network connections[/dim]")
        
        # Check for Volatility
        try:
            result = subprocess.run(['volatility', '--help'], capture_output=True, text=True, timeout=10)
            has_volatility = True
        except (subprocess.CalledProcessError, FileNotFoundError):
            has_volatility = False
        
        if has_volatility:
            dump_path = Prompt.ask("[cyan]Enter memory dump path for analysis[/cyan]")
            
            if not os.path.isfile(dump_path):
                self.display_result("Invalid memory dump path", "error")
                return
                
            self.console.print(f"[cyan]Analyzing memory dump: [green]{dump_path}[/green][/cyan]")
            self.console.print("[green]Memory dump analysis initiated (demo).[/green]")
            self.console.print("[dim]In a real implementation, this would use Volatility to detect injected processes, hidden modules, and network connections[/dim]")
        else:
            self.console.print("[red]Volatility not found. Install Volatility for memory forensic analysis.[/red]")
            self.console.print("[yellow]Feature not available: No memory analysis tools found. (Demo only)[/yellow]")
    
    def run(self):
        """Run malware analysis tools"""
        self.display_header("Malware Analysis Tools")
        
        # Add submenu for different types of malware analysis
        malware_table = Table(
            title="[bold cyan]Malware Analysis Options[/bold cyan]",
            show_header=True,
            header_style="bold magenta",
            border_style="cyan",
            box=box.ROUNDED
        )
        malware_table.add_column("ID", style="cyan", justify="center")
        malware_table.add_column("Analysis Type", style="green")
        malware_table.add_column("Description", style="white")
        malware_table.add_row("1", "Static Analysis", "Analyze malware without executing (YARA, strings, file type)")
        malware_table.add_row("2", "Dynamic Analysis", "Analyze malware behavior in sandbox (Cuckoo, ANY.RUN)")
        malware_table.add_row("3", "Network Monitoring", "Monitor network traffic for C2 communications")
        malware_table.add_row("4", "Memory Analysis", "Analyze memory dumps for malware artifacts")
        malware_table.add_row("5", "Back to Main Menu", "Return to main menu")
        
        self.console.print(malware_table)
        choice = Prompt.ask("Choose a malware analysis method", choices=["1", "2", "3", "4", "5"], default="1")
        
        if choice == "5":
            return
        
        # Add consent prompt for educational purpose
        self.console.print("[yellow]⚠[/yellow] This tool performs malware analysis for educational purposes only.")
        self.console.print("[yellow]⚠[/yellow] Always ensure you have proper authorization before analyzing any suspicious files.")
        consent = Prompt.ask("[bold magenta]Do you have explicit written consent to analyze this file? (yes/no)[/bold magenta]", default="no")
        if consent.lower() not in ['yes', 'y', 'true']:
            self.display_result("Analysis cancelled - explicit consent required", "warning")
            return
        
        self.console.print()
        
        if choice == "1":
            self.static_analysis()
        elif choice == "2":
            self.dynamic_analysis()
        elif choice == "3":
            self.network_monitoring()
        elif choice == "4":
            self.memory_analysis()